% ######################
% ### INITIALIZATION ###
% ######################

% make sure initMBPP was run first (also fillSelfObstacles is recommended)
if(~(exist('B', 'var') && exist('n', 'var')));
    initMBPP;
    B = fillSelfObstacles(B);
end

% Cell Dimensions
w = B(1).width;
l = B(1).length;
h = B(1).height;

% Access the appropriate HashTable of movements according to type of task
% (i.e. choose movements from given ethological category)
tableSize = n^3;
taskTable = ReturnTable(taskMap, task, tableSize);
weight_s = taskTable.weight_s;
weight_v = taskTable.weight_v;
scoreThresh = .5;

% general info on servos (used throughout code):
[servo_bounds ideal_pos servoNames ideal_rad] = get_servo_info();

% Get robot's current starting posture
allAngles = GetCurrPosture(sock);

% Calculate xyz coordinates of starting position and reduce angles depending
% on side (right or left) of arm
[right left rightJts leftJts] = ForwardKinematics_V5(allAngles);
currPosture = partial_posture_to_full(allAngles, side);

if(strcmp(side, 'right'))
    startXYZ = right;
elseif (strcmp(side, 'left'))
    startXYZ = left;
else
    disp('Error: please specify left or right side');
    return;
end

% Get cell indices of initial and final positions, which will be used as
% keys for movement lookup and storage
[~, ~, ~,key1] = findCell(startXYZ, n, w, l, h);
[~, ~, ~,key2] = findCell(targetXYZ, n, w, l, h);
key = [key1, key2];

tStart = tic; % for timing duration of processes

% #################
% ### MAIN LOOP ###
% #################

% Loop variables
path = [];              % Nx3 points for end effector
movement = [];          % Nx7 positions for servos on given side
collision_locs=NaN(1,3);% Mx3 points in B where collisions occured
done = false;           % loop control
planned = false;        % true if level 3 or 4 has run
generated = false;      % true if valid movement generated by level 2
adjusted = false;       % true if 
level = 1;              % the actual level var used by switch statement

num_simple_plan = 0;    % count # times level 3 executed
max_simple_plan = 4;    % after this many tries with level 3, go to level 4

while(~done)
    
    switch(level)
        
        % ################################
        % ### LEVEL 1 - MEMORY LOOK-UP ###
        % ################################
        
        case 1
            disp('Level 1 entered');
            
            % ############################
            % ### MEMORY & ADJUSTMENTS ###
            % ############################
            
            % If no given movement or path yet, check memory
            if(isempty(movement) && isempty(path))
                
                disp('Looking up stored movements...');

                % Look up stored movements
                % the lookup is 'fuzzy' because it will return the first
                % movement that has a final position within thresh of
                % targetXYZ.
                % if no stored movement brings us to within thresh, it
                % returns the closest and 'recalc' will be true
                [retMovement, retNode, recalc] = ...
                    fuzzyLookup(taskTable, key, targetXYZ, thresh);
                
                
                % if memory lookup failed, go to level 2
                if(isempty(retMovement) || retNode.Data.score < scoreThresh)
                    disp('No usable movements found. Going to level 2...');
                    level = 2;
                
                % If we find a movement whose score is above the min threshold
                else
                    
                    % If the final posture needs to be recalculated (i.e.
                    % movement in memory is close but not within thresh)
                    if(recalc)
                        disp('Adjusting stored movement.');
                        
                        % use movement generation (as seen in level 2) to
                        % go from final point of movement to endpoint
                        [B, finalPosture] = GenMovement(B, key2, ...
                            retMovement(end-1, :), path,side, weight_s, ...
                            weight_v, thresh);
                        movement = vertcat(retMovement(1:end-1, :), finalPosture);
                        
                        % indicate that adjustment was made
                        adjusted = 1;
                        
                    % stored movement was within thresh
                    else
                        disp('Applicable stored movement found.');
                        movement = retMovement;
                    end

                    % Check if movement is collision-free, simultaneously
                    % getting info on collision locations (used by level 3)
                    [is_valid collision_locs] = CheckMovement(B, movement, side);
                    if(~is_valid)
                        disp('Stored movement results in collisions. Going to level 3...');

                        movement = [];
                        level = 3;
                    end
                end

            % ##########################
            % ### MOVEMENT EXECUTION ###
            % ##########################
            
            elseif(~isempty(movement))
               
                % starting movement execution - stop algorithm timer
                tElapsed = toc(tStart);
                
                % for safety, allow user to see movement before enacting
                plot_movement_stills(B, movement, side);
                pause;
                
                % PHYSICALLY ENACT MOVEMENT
                EnactMovement(sock, movement, speed, side);
                
                % UPDATE MEMORY WITH MOVEMENT
                if(adjusted || generated)
                    % TODO (?) - storemovement average close movements rather
                    % than ignore
                    StoreMovement(B, taskTable, movement, side, thresh, ...
                        weight_s, weight_v);
                end

                % Algorithm Finished
                disp('Target achieved.');
                done = 1; 

            % We have a path, but not a movement
            % Go to Level 2 for movement generation given a path
            else
                disp('Path available, but no movements. Going to level 2...');
                level = 2;
            end

        % #####################################
        % ### LEVEL 2 - MOVEMENT GENERATION ###
        % #####################################
        
        case 2

            disp('Level 2 entered');

            % If a path is available, generate a movement for that path and
            % store it
            if(~isempty(path))
                
                % Generate movement from path
                [B, movement] = GenMovement(B, key2, currPosture, path, side, weight_s, weight_v, thresh);
                
                % increase resolution of movement by linearly interpolating 
                % postures (makes checking collisions and visualization easier)
                movement = break_down_movement(movement, pi/16);
                
                % check for collisions
                [is_valid collision_locs] = CheckMovement(B, movement, side);
                
                % Could not generate a collision-free movement
                if(isempty(movement) || ~is_valid)
                    % show movement visualization
                    plot_movement_stills(B, movement, side);
                    title('Level 2 movement: COLLISION');
                    
                    % either go to level 3 or 4, depending on number of
                    % times level 3 was attempted.
                    if(num_simple_plan > max_simple_plan)
                        level = 3;
                    else
                        level = 4;
                        disp('Could not generate a collision-free movement. Going to level 4.');
                    end
                    
                % collision-free movement generated - enact it.
                else
                    generated = 1;
                    level = 1;
                end
                
            % no path - start over with level 3
            else
                disp('no path given. go to level 3');
                level = 3;
                num_simiple_plan = 0;
                collision_locs = NaN(1,3);
            end
        
        % #################################
        % ### LEVEL 3 - SIMPLE PLANNING ###
        % #################################
        
        case 3
            disp('Level 3 entered');
            
            % WAYPOINTS ALGORITHM
            
            collisions_com = NaN(1,3);
            if(~isempty(collision_locs))
                coll_x = collision_locs(:,1);
                coll_y = collision_locs(:,2);
                coll_z = collision_locs(:,3);
                collisions_com = [mean(coll_x) mean(coll_y) mean(coll_z)];
            end
            
            % if path has at least 2 points, add to it
            if(exist('path', 'var') && size(path, 1) >= 2)
                [new_path is_valid] = add_waypoints(B, path, 5, collisions_com);
                
            % otherwise, initialize path to [start; goal] and add waypoints
            % from there
            else
                [new_path is_valid] = add_waypoints(B, [startXYZ; targetXYZ], 5, collisions_com);
            end
            
            % cut corners where line of sight exists
            path = cut_path_corners(B, new_path);
            
            num_simple_plan = num_simple_plan + 1;
            level = 2;
            
            plot_path(B, path);
            title(['path generated from ' num2str(num_simple_plan) ...
                ' iterations of waypoint algorithm']);


% % OLD LEVEL 3:
%             path = StraighLinePlan(B, startXYZ, targetXYZ, w);
% %             path = sparsify_path(path);
%             is_valid = CheckPath(B,path);
%             plot_path(B,path);
%             planned = 1;
%             %If path is valid, go to Level 2 to generate a movement for the
%             %path
%             if(is_valid)
%                 level = 2;
%             %Else go to Level 4 for more intelligent path planning
%             else
%                 path = [];
%                 level = 4;
%             end



        % ##################################
        % ### LEVEL 4 - COMPLEX PLANNING ###
        % ##################################
        
        case 4
            disp('Level 4 entered');

            %path = A_ComputePath(startXYZ,targetXYZ,key(1),key(2), B,thresh);
            [path,Movement,tElapsed,Bmod] = A_ComputePath(zeros(1,11),[5,12,5],B,2)
            path = sparsify_path(path);
            is_valid = CheckPath(B,path);
            planned = 1;
            %If path is valid, go to Level 2 to generate a movement for the
            %path
            if(is_valid)
                level = 2;
                plot_path(B, path);
            %Else no path exists
            else
                path = [];
                done = -1; 
                disp('No path exists. Target is unreachable.');
            end


        %DEFAULT
        otherwise
            disp('Error: Main controller entered nonexistent level');
            done = -1;
            return;
    end
    fprintf('\n\n ======= level completed =======\n\n');
    pause;
end
